// import the library for the version of workbox you are using above
importScripts(
  "https://storage.googleapis.com/workbox-cdn/releases/5.1.4/workbox-sw.js"
);
// imports for using indexedDB using idb library
importScripts("/src/js/idb.js"); // idb is a package to wrap the indexedDB api to use promises instead of callbacks.
// importScripts is how you can import javascript into your service worker code
importScripts("/src/js/utility.js");

/**
 * This base sw file is used to build upon using the injectManifest script from Workbox
 * You can use this approach to customize your caching and implement routing, etc.
 * The cache list file manifest generated by Workbox-cli is injected into this file and the result is copied to service-worker.js
 */

workbox.setConfig({
  debug: true, // set if you want to see console log statements
});

// Use the imported Workbox libraries to dynamically cache route responses:
const { registerRoute } = workbox.routing;
const { NetworkFirst, StaleWhileRevalidate } = workbox.strategies;
// cache strategies to use:
const { ExpirationPlugin } = workbox.expiration;

/**
 * NOTE: The order you register routes in matters (like a Switch Router)
 * - More specific routes need to come BEFORE more general route matches
 *    - for instance the post images cache route needs to come first because it includes googleapis which
 *      would have been caught by the latter google font route since it is more general and captures that
 *   (the post images cache would not be created)
 */

// make sure firebase stored images from posts don't go into the google api fonts cache above
registerRoute(
  /.*(?:firebasestorage\.googleapis)\.com.*$/,
  new StaleWhileRevalidate({ cacheName: "post-images" })
);

// Dynamic caching/routing for google fonts - use the reg exp to capture all requests in index.html to google apis for font loading and cache the response
registerRoute(
  /.*(?:googleapis|gstatic)\.com.*$/,
  new StaleWhileRevalidate({
    cacheName: "google-fonts",
    plugins: [
      // this sets a timestamp entry in indexedDB for the assets which it manages and checks to automatically remove when expiration comes
      new ExpirationPlugin({
        maxEntries: 3, // we only have 3 fonts we're using, don't store more
        maxAgeSeconds: 60 * 60 * 24 * 30, // not necessarily with staleWhileRevalidate, but done here for example
      }),
    ],
  }) // this reaches out to the cache to get the resource, but also makes a request which if successful, will replace the cached item with the updated resource -
);

// Dynamically cache Material-Design lite css CDN assets:
// note: you can pass in @variablename syntax to the express url in the first arg if needed
registerRoute(
  "https://cdnjs.cloudflare.com/ajax/libs/material-design-lite/1.3.0/material.indigo-pink.min.css",
  new StaleWhileRevalidate({ cacheName: "material-css" })
);

// custom route handling strategy, but still take advantage of Workbox routing management
// can be used if you need a caching strategy that is not provided by WB library (for instance, an indexedDB strategy)
// pass a second argument function which takes args representing the fetch request event
registerRoute(
  "https://pwa-practice-app-289604.firebaseio.com/posts.json",
  (args) => {
    // return a promise that yields a response.  access the fetch event on args
    return fetch(args.event.request).then((res) => {
      // clear storage in indexedDB to prevent sync errors (deleted item from backednd remaining stored in cache)
      var clonedRes = res.clone();

      clearAllData("posts")
        .then(() => {
          // store this dynamic data in indexedDB.  Make a clone, Transform and store it
          return clonedRes.json();
        })
        .then((data) => {
          Object.keys(data).forEach((key) => {
            writeData("posts", data[key]);
          });
        });
      // return the original request
      return res;
    });
  }
);

workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);
