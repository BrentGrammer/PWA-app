# WORKBOX

- Tool by Google for automatic service worker management
- Can use it with Gulp/Webpack various project setups or just the cli with straight scripts
- Note that you can still add custom service worker code to your Workbox implementation (using injectManifest script and a base service worker file)
- [DOCS](https://developers.google.com/web/tools/workbox/modules/workbox-cli)

## Setup

- Install as a dev dependency: `npm install --save-dev workbox-cli` for v2
  - v3 is the latest as of this date
- write an npm script in `package.json` to use it to generate a service worker:
  - `"generate-sw": "workbox wizard && workbox generateSW workbox-config.js"`
    - This will analyze your files and automatically generate a config file to cache them (you can change this config file to tweak caching later)
    - \*\*\* Note: File name must be matched. If you had changedworkbox-config.js" to something else, please replace with your file name.
    - You can setup scripts for various workbox actions as follows:
    ```json
    "scripts": {
        // ...,
        "injectManifest": "workbox injectManifest workbox-config.js",
        "generate-sw": "workbox generateSW workbox-config.js",
        "wb-init": "workbox wizard && workbox generateSW workbox-config.js"
      },
    ```
  - run the script for `workbox wizard && workbox generateSW workbox-config.js`
    - choose the root of the web app when prompted (where index.html is served)
    - Follow prompts (can store everything to start with)
    - Troubleshooting: if you get a require error on generating the config file, **do not enter** `Y` to the later prompts, just press `enter` to save config when prompted.
- Where you register your service worker and point to the file, make sure the path points to the generated sw you made with the workbox-cli:

```javascript
navigator.serviceWorker.register("/service-worker.js");
```

### Workbox basic config file:

```javascript
module.exports = {
  globDirectory: "public/", // where do files to cache live
  globPatterns: [
    "**/*.{html,ico,json,css,png,jpg,js}", // any folder in public, any file name with any of these extensions should get cached.  Paths here are relative to the globDirectory defined above
  ],
  // *** DO NOT USE swSrc if running generateSW...only needed for injectManifest
  swSrc: "public/sw-base.js", // file to build upon and use for url routing /precaching with injectManifest - see Routing/Dynamic caching section below
  swDest: "public/service-worker.js", // where is the service worker file
  globIgnores: ["../workbox-config.js", "help/**"], // do not cache these files
};
```

(After changing this config anytime, run `workbox generateSW workbox-config.js` or make a script for it)

## Features

- Will automatically update the version if you run the generate command with Workbox-cli for development
- Puts all files specified in the config into the cache on install

## Development

- When you make changes to the service-worker or config file, run the script that runs `workbox generateSW workbox-config.js` (make an npm script for it) if you are not using injectManifest
  - generates a new service worker and overwrites the old one
- **If you are using injectManifest**: Run the injectManifest script every time you make changes to your base sw file or any of your other files, not the generateSW script above:
  - `workbox injectManifest workbox-config.js`
- After this, `Application -> clear storage -> Clear site data` in dev tools and reload the tab twice

## Routing / Dynamic Caching with Workbox

### injectManifest

- use [`injectManifest`](https://developers.google.com/web/tools/workbox/modules/workbox-cli#injectmanifest) to cache the response for certain defined urls to which requests are sent (i.e. CDN requests for css or font files, etc.)
- You can build on an input service worker file that you create separate from the main service-worker.js file to help manage this (the service-worker.js file will be overwritten every time it is generated.)
- You can take the fileManifest array from the generated `service-worker.js` file and inject it into a new file you specify, i.e. `sw-base.js` or something like that
- Note `injectManifest` can also be used for pre-caching purposes

### Using injectManifest:

- Create a script to replace your original `generate-sw` npm script in package.json:
  - `"generate-sw": "workbox injectManifest workbox-config.js"`
    - the last part is the path to your config file generated by workbox
    - You may need to run the script `workbox wizard && workbox generateSW workbox-config.js` if you don't already have the generated files.
- Update your workbox-config.js file to set a `swSrc` to the file you want to build on and inject urls to precache into:

  - `swSrc: "public/sw-base.js",`
  - run the injectManifest script to generate a new service-worker.js

- Your `sw-base.js` file is what you edit and do work in. Workbox will use it to build on and generate a new `service-worker.js`
- In your `sw-base.js` file you can use the CDN workbox library to dynamically cache routes for things such as google fonts, CDN requests, etc.
  - using a `staleWhileRevalidate` strategy will check the cache for the asset and also fetch the resource and use or update the cache with it. (cache then network strategy)

Example `sw-base.js` file:

```javascript
// import the library for the version of workbox you are using
importScripts(
  "https://storage.googleapis.com/workbox-cdn/releases/5.1.4/workbox-sw.js"
);

workbox.setConfig({
  debug: true, // may not be needed or only during development - see console log statements
});

// Use the imported Workbox libraries to dynamically cache route responses:
const { registerRoute } = workbox.routing;
const { NetworkFirst, StaleWhileRevalidate } = workbox.strategies;

/**
 * NOTE: The order you register routes in matters (like a Switch Router)
 * - More specific routes need to come BEFORE more general route matches
 *    - for instance the post images cache route needs to come first because it includes googleapis which
 *      would have been caught by the latter google font route since it is more general and captures that
 *   (the post images cache would not be created)
 */

// make sure firebase stored images from posts don't go into the google api fonts cache above
registerRoute(
  /.*(?:firebasestorage\.googleapis)\.com.*$/,
  new StaleWhileRevalidate({ cacheName: "post-images" })
);

// Dynamic caching/routing for google fonts - use the reg exp to capture all requests in index.html to google apis for font loading and cache the response
registerRoute(
  /.*(?:googleapis|gstatic)\.com.*$/,
  new StaleWhileRevalidate({ cacheName: "google-fonts" }) // this reaches out to the cache to get the resource, but also makes a request which if successful, will replace the cached item with the updated resource -
);

// Dynamically cache Material-Design lite css CDN assets:
// note: you can pass in @variablename syntax to the express url in the first arg if needed using express syntax
registerRoute(
  "https://cdnjs.cloudflare.com/ajax/libs/material-design-lite/1.3.0/material.indigo-pink.min.css",
  new StaleWhileRevalidate({ cacheName: "material-css" })
);

workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);
```

## Strategies

- See [DOCS](https://developers.google.com/web/tools/workbox/modules/workbox-strategies) for updated configuration options
- You can use a number of caching strategies that the `workbox.strategies` library provides:

  - `CacheFirst`: Check the cache, then fallback to network if not found.
  - `CacheOnly`: Just look at the cache
  - `NetworkFirst`: Check the network first and go to cache if network fails
  - `NetworkOnly`: only check the network
  - `StaleWhileRevalidate`: Cache, then Network (always check the network, not just fallback)

- You can pass in configuration to these strategies

  - `cacheName`
  - Plugins: see docs and file example:

    - [`ExpirationPlugin`: { `maxEntries`, `maxAgeSeconds` }](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-expiration): Limit the number of assets stored in that cache and fetch updated versions if the max age has expired
    - [Broadcast Cache Update plugin: not used often](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-broadcast-update)
    - [Cacheable Response:](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-cacheable-response) Can cache responses based on status codes, headers etc.
    - [Background Sync Plugin](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-background-sync)
      - [See Example Usage here](https://developers.google.com/web/tools/workbox/modules/workbox-background-sync)
      - Note that you can install plugin libraries from Workbox via npm: (https://www.npmjs.com/package/workbox-background-sync)
    - [Range Requests Plugin](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-range-requests)

    Ex:

    ```javascript
    registerRoute(
      /.*(?:googleapis|gstatic)\.com.*$/,
      new StaleWhileRevalidate({
        cacheName: "google-fonts",
        plugins: [
          // this sets a timestamp entry in indexedDB for the assets which it manages and checks to automatically remove when expiration comes
          new ExpirationPlugin({
            maxEntries: 3, // we only have 3 fonts we're using, don't store more
            maxAgeSeconds: 60 * 60 * 24 * 30, // not necessarily with staleWhileRevalidate, but done here for example
          }),
        ],
      })
    );
    ```

### Custom Strategies

- Make a custom handler for a route with a custom caching strategy you define outside of what Workbox provides. You still take advantage of Workbox routing management.
  - There may not be an indexedDB strategy for example.
- Pass a function to the second argument of `registerRoute` which takes `args` that is the request event (the `fetch` event) - this contains info about the request sent

  - Return a promise that yields a response

  ```javascript
  // custom route handling strategy, but still take advantage of Workbox routing management
  // can be used if you need a caching strategy that is not provided by WB library (for instance, an indexedDB strategy)
  // pass a second argument function which takes args representing the fetch request event
  registerRoute(
    "https://pwa-practice-app-289604.firebaseio.com/posts.json",
    (args) => {
      // return a promise that yields a response.  access the fetch event on args
      return fetch(args.event.request).then((res) => {
        // clear storage in indexedDB to prevent sync errors (deleted item from backednd remaining stored in cache)
        var clonedRes = res.clone();

        clearAllData("posts")
          .then(() => {
            // store this dynamic data in indexedDB.  Make a clone, Transform and store it
            return clonedRes.json();
          })
          .then((data) => {
            Object.keys(data).forEach((key) => {
              writeData("posts", data[key]);
            });
          });
        // return the original request
        return res;
      });
    }
  );
  ```

### Handle custom offline page caching and serving:

```javascript
// Pass a function as the first argument to target specific routes based on their headers, etc.
// This is to cache the offline fallback page we created - need to do this because we want to return a specific html page respnse if certain conditions are met
workbox.routing.registerRoute(
  function (routeData) {
    // you have access to the request route in here through routeData - you can check the headers for all requests asking for html pages
    return routeData.event.request.headers.get("accept").includes("text/html");
  },
  function (args) {
    // in your custom handler, return the requested html page requested if possible, or the fallback offline.html page if not possible
    return caches.match(args.event.request).then(function (responseInCache) {
      if (responseInCache) {
        // return the res for the request in the cache if it is already stored
        return responseInCache;
      } else {
        // fallback to network req if html page not found in the cache
        return fetch(args.event.request)
          .then(function (res) {
            // store the response in cache if successful network response
            return caches.open("dynamic").then(function (cache) {
              cache.put(args.event.request.url, res.clone());
              return res;
            });
          })
          .catch(function (err) {
            // if you error on the request, then fallback to getting our custom offline page from the cache
            // using workbox.precaching.getCacheKeyForURL() instead of just 'offline.html - needed for WB v5
            return caches
              .match(workbox.precaching.getCacheKeyForURL("/offline.html"))
              .then(function (res) {
                return res;
              });
            // Our offline.html page is cached in the workbox-config.js since we cache all html request responses in the globPatterns property
          });
      }
    });
  }
);
```

### Push Notifications with Workbox

- There is currently no fitting strategy or helper for handling push notifications
- Add your custom push notification code (code regarding background synchronization and push messages) to the base service worker file you use to build upon with injectManifest (`sw-base.js`)
  - Can add this code after the `precaching.preCacheAndRoute()` line (see `sw-base.js`)

### Background Sync with Workbox

- You need to write your own implementation for this and add it into the base sw file
- [See this post on when sync occurs](https://stackoverflow.com/questions/53786395/service-workers-when-does-the-browser-sync-back-again):
  - 5 minutes after and 15 minutes after a connection is established?
- Manually fire a sync event in the browser: got to dev tools -> Application -> Service Workers and enter your sync tag into the Sync field and press `Sync`
- If you don't see a sync event when reconnecting in Chrome, you may need to wait 5 or 15 minutes, or just send another request which will trigger the sync event.
- You can use the background-sync plugin from Workbox if you want as well as make your custom implementation (see `sw-base.js`)

## Further Resources

- [Cook book](https://developers.google.com/web/tools/workbox/guides/common-recipes)
