/**
 * Before course update refactors. Left for reference.
 */

const functions = require("firebase-functions");
const admin = require("firebase-admin");
const cors = require("cors")({ origin: true });
// use web-push package for push notifications
const webpush = require("web-push");
// pavkage makes accessing form data easier
const formidable = require("formidable");
const UUID = require("uuid-v4");
const fs = require("fs"); // default node file sys package
// gitignored secrets:
const KEYS = require("./secrets");

/**
 * This file was deprecated due to a new google cloud storage version which does not need formidable, but busboy to parse formdata sent to a buffer
 */

// config for google cloud storage (install the @google-cloud/storage package for your project)
const gcconfig = {
  projectId: KEYS.googleProjectId,
  keyFileName: "pwagram-fb-key.json", // service account json file: don't include the ./ in the string here
};

const { Storage } = require("@google-cloud/storage");
const gcs = new Storage(gcconfig);

// // Create and Deploy Your First Cloud Functions
// // https://firebase.google.com/docs/functions/write-firebase-functions
//
const serviceAccount = require("./pwagram-fb-key.json");
//initialize app - go to firebase console for database url and credentials
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://pwa-practice-app-289604.firebaseio.com/",
});
exports.storePostData = functions.https.onRequest((request, response) => {
  // wrap the response with cors to automatically send the right headers etc. for cross origin access
  return cors(request, response, function () {
    // initialize a helper from formidable to use to extract form data
    const formData = new formidable.IncomingForm();
    // parse the form data from the request and use the callback
    formData.parse(request, (err, fields, files) => {
      // access the file with a property name that matches the name you used on the front end (in sw.js in the sync callback to send form data)
      // move the file temporarily and change the temp path set on the file to another temporary dir on google cloud functions
      // the reason to move the file is to make sure that there is not an unexpected cleanup of the default path the file is set in
      fs.rename(files.file.path, "/tmp/" + files.file.name);
      // upload the file into a bucket: find the default bucket name in Firebase Console -> Storage and copy the string after gs://
      const bucket = gcs.bucket("pwa-practice-app-289604.appspot.com");

      const uuid = UUID();
      // pass in a config object to the second arg with file type and metadata
      bucket.upload(
        "/tmp/" + files.file.name,
        {
          uploadType: "media",
          metadata: {
            metadata: {
              contentType: files.file.type, // provided by formidable
              // generate a public url to download the file (use the package uuid-v4)
              firebaseStorageDownloadTokens: uuid, // firebase generates a public url using this
            },
          },
        },
        (err, file) => {
          if (!err) {
            // follows pattern generated by firebase and uses the uuid token
            const publicImageUrl =
              "https://firebasestorage.googleapis.com/v0/b/" +
              bucket.name +
              "/o/" +
              encodeURIComponent(file.name) +
              "?alt=media&token=" +
              uuid;

            storePostInDatabase(fields, publicImageUrl);
          } else {
            console.error(err);
          }
        }
      );
    });

    response.set("Access-Control-Allow-Origin", "*");

    function storePostInDatabase(formFields, publicImageUrl) {
      admin
        .database()
        .ref("posts")
        .push({
          id: formFields.id,
          title: formFields.title,
          location: formFields.location,
          image: publicImageUrl,
        })
        .then(() => {
          // add vapid key security for push notifications (ensures they only come from your server to users)
          // pass identifier of self(email addr), the vapid public key, and the private vapid key (generated with npm package)
          webpush.setVapidDetails(
            "mailto:myemail@email.com",
            KEYS.publicVapidKey,
            KEYS.secretVapidKey
          );
          // fetch subscriptions to send push notifications to
          return admin.database().ref("subscriptions").once("value"); // get value of the node once in fb
        })
        .then((subscriptions) => {
          subscriptions.forEach((sub) => {
            // config sent to web push
            const pushConfig = {
              endpoint: sub.val().endpoint, // the endpoint for the browser vendor server stored in the subscription in the database
              keys: {
                auth: sub.val().keys.auth,
                p256dh: sub.val().keys.p256dh,
              },
            };
            // sned push notification for each subscription
            // the second arg is a payload you send with the push notification
            // (the payload is used by the front end.  Pass whatever you want, this is not predefined). NOTE: there is a limit to the size of data you can send - images may be too big
            // returns a promise, just catch and handle errors
            webpush
              .sendNotification(
                pushConfig,
                JSON.stringify({
                  title: "New post",
                  content: "New Post added",
                  openUrl: "/help", // used to tell front end what page to open when notification is clicked - this is absolute from the server/domain, can be any url
                })
              )
              .catch((err) => {
                console.error(err);
              });
          });

          response
            .status(201)
            .json({ message: "Data stored", id: request.body.id });
        })
        .catch((err) => {
          response.status(500).json({ error: err });
        });
    }
  });
});
